import os
import os.path
import re
import shutil
import tarfile
import tempfile
from typing import Any

import click
import github
import requests
import yaml  # type: ignore[import]

from hitchhiker.cli.modules.list import discover_modules
from hitchhiker.release.version import semver


# pylint: disable=R0901
class IndentDumper(yaml.Dumper):  # type: ignore[misc]
    def increase_indent(
        self, flow: bool = False, indentless: bool = False
    ) -> Any:  # the indentless argument is required
        return super().increase_indent(flow, False)


# pylint: disable=R0801
def _get_github_token(ctx: click.Context) -> str:
    print(os.environ)
    if "GITHUB_TOKEN" not in os.environ and not ctx.obj["CONF"].has_key("GITHUB_TOKEN"):
        raise click.UsageError(
            "GitHub token not found, set the GITHUB_TOKEN environment variable or config option"
        )
    return os.environ.get(
        "GITHUB_TOKEN",
        (
            ctx.obj["CONF"].get_key("GITHUB_TOKEN")
            if ctx.obj["CONF"].has_key("GITHUB_TOKEN")
            else None
        ),
    )


def _get_repo_mod_versions(
    ctx: click.Context, repo: str, odoo_version: int
) -> dict[str, tuple[semver.Version, str]]:
    """
    Retrieves the latest version from a module repo

    Parameters:
        ctx (click.Context): The Click context object.

    Returns:
        dict[str, tuple[semver.Version, str]]: dict[modulename, tuple[version, tgzurl]].

    """
    try:
        gh = github.Github(_get_github_token(ctx))
        releases = gh.get_repo(repo).get_releases()
    except Exception as e:
        click.secho(
            "Error getting releases from GitHub. Is something wrong with your token?",
            err=True,
            fg="red",
        )
        raise e
    ret = {}
    release_name_regex = rf"^{odoo_version}\.0-v?(\d+\.\d+\.\d+)$"
    release = sorted(
        list(filter(lambda r: re.match(release_name_regex, r.title), releases)),
        key=lambda r: semver.Version().parse(
            re.match(release_name_regex, r.title).group(1)  # type: ignore[union-attr]
        ),
    )[0]
    module_list_ent_regex = (
        r"^\| (?P<name>\w+) (?::boom: )?\| (?P<version>\d+\.\d+\.\d+) (?::new: )?\|$"
    )
    for line in release.body.splitlines():
        match = re.match(module_list_ent_regex, line)
        if match is not None:
            ret[match.group("name")] = (
                semver.Version().parse(match.group("version")),
                release.tarball_url,
            )
    return ret


@click.group("repo")
@click.pass_context
def repo_group(ctx: click.Context) -> None:
    """
    Commands related to Customer repos
    """
    ctx.ensure_object(dict)


@click.command(name="create", short_help="Create vogon.yaml and populate it")
@click.option(
    "--glob",
    is_flag=False,
    default="./**/__manifest__.py",
    help="module search path glob",
)
@click.option(
    "--overwrite",
    is_flag=True,
    default=False,
    help="overwrite the vogon.yaml even if it already exists",
)
@click.pass_context
def create_cmd(_ctx: click.Context, glob: str, overwrite: bool) -> None:
    """
    Creates vogon.yaml and populates it with modules found in the current working directory

    Parameters:
        --glob (str): The glob pattern to search for Odoo modules (default: `./**/__manifest__.py`).
        --overwrite (bool): allows overwriting the vogon.yaml

    """
    if not overwrite and os.path.isfile("vogon.yaml"):
        click.echo("vogon.yaml already exists and --overwrite is not set")
        return
    modules = discover_modules(glob)
    modules.sort(key=lambda x: x.get_int_name())
    click.echo("Creating vogon.yaml")
    with open("vogon.yaml", "w", encoding="utf-8") as f:
        mods = []
        for module in modules:
            mod = {}
            mod["name"] = module.get_int_name()
            path = str(os.path.dirname(module.get_dir()))
            if path != ".":
                mod["path"] = path
            version = module.get_version()
            if version is not None:
                mod["version"] = str(version)
            mods.append(mod)
        f.write(
            """# Example:
#odoo_version: 17
#modules:
#  - name: test_abc
#    path: ./test_modules
#    version: 0.1.0
#    git: 42nerds/module_test_inroot
#    git_path: . # by default git path will be the same as the module name
#  - name: test_abcd
#    path: ./test_modules
#    use_latest: true # if true will always clone the latest version. False by default
#    version: 0.3.0
#    git: 42nerds/module_test
#  - name: another_module
#    version: 0.3.0
#    git: 42nerds/module_test
#  - name: module_without_git
#    version: 0.0.5
# Autogenerated from modules found in the current working directory:
"""
        )
        f.write("odoo_version: 0 # set this\n")
        f.write(
            yaml.dump(
                {"modules": mods},
                indent=2,
                sort_keys=False,
                Dumper=IndentDumper,
                allow_unicode=True,
            )
        )


repo_group.add_command(create_cmd)


# prospector: disable=MC0001
# pylint: disable=R0901,R0914
@click.command(name="update", short_help="Update modules")
@click.option(
    "--module",
    is_flag=False,
    default=None,
    help="updates only one module",
)
@click.pass_context
def update_cmd(ctx: click.Context, module: str) -> None:
    """
    Finds the latest version for all modules in vogon.yaml and updates their versions in the file.
    Then it downloads each tarball and extracts it in the correct directory (if the version does not match)

    Parameters:
        --module (str): Update only a single module

    """
    if not os.path.isfile("vogon.yaml"):
        click.echo("no vogon.yaml found")
        return
    with open("vogon.yaml", "r", encoding="utf-8") as f:
        conf = yaml.safe_load(f)
    to_update = conf["modules"]
    if module is not None:
        try:
            to_update = [
                next(item for item in conf["modules"] if item["name"] == module)
            ]
        except StopIteration:
            click.echo(f"module {module} not found")
            return
    git_mods = {}  # keeps track of github release requests
    git_repos_downloaded = {}  # keeps track of tarballs we downloaded
    conf["modules"] = []  # we add the modules back into the list after we made changes.
    for mod in to_update:
        repo = mod.get("git")
        if repo is None:  # no git repo set, continuing is pointless
            conf["modules"].append(mod)
            continue
        # get the release info if we didn't already
        if repo not in git_mods:
            git_mods[repo] = _get_repo_mod_versions(ctx, repo, conf["odoo_version"])
        if mod["name"] not in git_mods[repo]:
            click.echo(f"module {mod['name']} not found in repo {repo}")
            return
        # is there a newer version available?
        if not mod.get("use_latest") and not (
            git_mods[repo][mod["name"]][0] > semver.Version().parse(mod["version"])
        ):
            click.echo(f"no newer version for {mod['name']} in repo {repo}")
            conf["modules"].append(mod)
            continue
        click.echo(
            f"updating {mod['name']} to {str(git_mods[repo][mod['name']][0])} from { mod['version']}"
        )
        mod["version"] = str(
            git_mods[repo][mod["name"]][0]
        )  # set the version to our new version
        conf["modules"].append(mod)
        # get the tarball if we didn't already
        if repo not in git_repos_downloaded:
            fname = f"release_{repo.replace('/', '_')}.tar.gz"
            req = requests.get(
                git_mods[repo][mod["name"]][1],
                allow_redirects=True,
                headers={"Authorization": f"Bearer {_get_github_token(ctx)}"},
                timeout=30,
            )
            with open(fname, "wb") as f:  # type: ignore[assignment]
                f.write(req.content)  # type: ignore[arg-type]
            git_repos_downloaded[repo] = fname
        # initialize our paths
        mod_path = mod.get("path", ".") + "/" + mod["name"]
        git_path = mod.get("git_path", f"./{mod['name']}")
        # extract the tar file to a temporary directory, then copy what we need and delete it again
        with tarfile.open(git_repos_downloaded[repo]) as tar:
            # https://stackoverflow.com/a/43094365
            def remove_top_dir(tf: Any) -> Any:
                top = (
                    os.path.commonprefix(tf.getnames()) + "/"
                )  # NOTE: works ONLY with module repos
                for member in tf.getmembers():
                    if member.path.startswith(top):
                        member.path = member.path[len(top):]
                        yield member

            with tempfile.TemporaryDirectory() as tmpdir:
                tar.extractall(path=tmpdir, members=remove_top_dir(tar))
                if os.path.isdir(mod_path):
                    shutil.rmtree(mod_path)
                shutil.copytree(tmpdir + "/" + git_path, mod_path)
    # delete the tarballs we donwloaded
    for fname in git_repos_downloaded.values():
        os.remove(fname)
    # write back to our config
    with open("vogon.yaml", "w", encoding="utf-8") as f:
        f.write(
            yaml.dump(
                conf,
                indent=2,
                sort_keys=False,
                Dumper=IndentDumper,
                allow_unicode=True,
            )
        )


repo_group.add_command(update_cmd)
